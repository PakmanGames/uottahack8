// lib/terraform-generator.ts
import { PlacedComponent, Order } from "./types";

// Generate a unique suffix for globally-unique resource names
function generateUniqueSuffix(): string {
  return Math.random().toString(36).substring(2, 8);
}

// Context passed to resource generation for auto-wiring
interface ResourceContext {
  suffix: string;
  dropletResourceNames: string[];
  spacesResourceName: string | null;
  hasSpaces: boolean;
}

export function generateTerraformCode(
  placedComponents: PlacedComponent[],
  order: Order | null
): string {
  if (placedComponents.length === 0) {
    return `# Drag components to the build area to generate Terraform code
# Customer: ${order?.customer.name || "Waiting..."}
# Order: ${order?.scenario || "No order yet"}`;
  }

  const suffix = generateUniqueSuffix();
  const monthlyCost = calculateMonthlyCost(placedComponents);

  // Pre-scan to collect resource names for auto-wiring
  const componentCounts: Record<string, number> = {};
  const dropletResourceNames: string[] = [];
  let spacesResourceName: string | null = null;

  placedComponents.forEach((placed) => {
    const type = placed.component.type;
    componentCounts[type] = (componentCounts[type] || 0) + 1;
    const index = componentCounts[type];
    const resourceName = `${type.replace(/-/g, "_")}_${index}`;

    // Track droplets for auto-wiring
    if (type.startsWith("droplet-")) {
      dropletResourceNames.push(resourceName);
    }
    // Track first spaces bucket for CDN
    if (type === "spaces" && !spacesResourceName) {
      spacesResourceName = resourceName;
    }
  });

  const context: ResourceContext = {
    suffix,
    dropletResourceNames,
    spacesResourceName,
    hasSpaces: spacesResourceName !== null,
  };

  // Header with deployment instructions
  const lines: string[] = [
    `# Generated by Papa's DO-eria`,
    `# Customer: ${order?.customer.name || "Unknown"} | Order: ${order?.scenario || "Custom Build"}`,
    `# Estimated Monthly Cost: $${monthlyCost}/mo`,
    `#`,
    `# DEPLOY INSTRUCTIONS:`,
    `# 1. Save this file as main.tf`,
    `# 2. Run: terraform init`,
    `# 3. Run: terraform apply -var="do_token=YOUR_TOKEN"`,
    `#`,
    `# Get your DO token: https://cloud.digitalocean.com/account/api/tokens`,
    "",
    "terraform {",
    "  required_providers {",
    "    digitalocean = {",
    '      source  = "digitalocean/digitalocean"',
    '      version = "~> 2.0"',
    "    }",
    "  }",
    "}",
    "",
    'variable "do_token" {',
    '  description = "DigitalOcean API Token"',
    "  type        = string",
    "  sensitive   = true",
    "}",
    "",
    'provider "digitalocean" {',
    "  token = var.do_token",
    "}",
    "",
  ];

  // Reset counts for actual generation
  const generationCounts: Record<string, number> = {};
  const generatedResources: {
    droplets: string[];
    databases: string[];
    loadBalancers: string[];
    spaces: string[];
  } = {
    droplets: [],
    databases: [],
    loadBalancers: [],
    spaces: [],
  };

  // Generate resources
  placedComponents.forEach((placed) => {
    const { component } = placed;
    const type = component.type;

    generationCounts[type] = (generationCounts[type] || 0) + 1;
    const index = generationCounts[type];
    const resourceName = `${type.replace(/-/g, "_")}_${index}`;

    const resourceLines = generateResourceBlock(component, resourceName, index, context);
    if (resourceLines.length > 0) {
      lines.push(...resourceLines);
      lines.push("");

      // Track for outputs
      if (type.startsWith("droplet-")) {
        generatedResources.droplets.push(resourceName);
      } else if (["postgres", "mysql", "redis", "mongodb"].includes(type)) {
        generatedResources.databases.push(resourceName);
      } else if (type === "load-balancer") {
        generatedResources.loadBalancers.push(resourceName);
      } else if (type === "spaces") {
        generatedResources.spaces.push(resourceName);
      }
    }
  });

  // Generate outputs
  lines.push(...generateOutputs(generatedResources));

  return lines.join("\n");
}

function generateResourceBlock(
  component: PlacedComponent["component"],
  resourceName: string,
  index: number,
  context: ResourceContext
): string[] {
  const lines: string[] = [];
  const { suffix, dropletResourceNames, spacesResourceName, hasSpaces } = context;

  switch (component.type) {
    case "droplet-basic":
    case "droplet-general":
    case "droplet-cpu":
    case "droplet-memory":
      const dropletSize = component.terraformConfig.size as string;
      const dropletName = `${component.name.toLowerCase().replace(/[^a-z0-9]/g, "-")}-${suffix}-${index}`;
      lines.push(
        `resource "digitalocean_droplet" "${resourceName}" {`,
        `  image  = "ubuntu-22-04-x64"`,
        `  name   = "${dropletName}"`,
        `  region = "nyc3"`,
        `  size   = "${dropletSize}"`,
        "",
        `  tags = ["terraform", "papa-do-eria"]`,
        "}"
      );
      break;

    case "postgres":
      lines.push(
        `resource "digitalocean_database_cluster" "${resourceName}" {`,
        `  name       = "postgres-${suffix}-${index}"`,
        `  engine     = "pg"`,
        `  version    = "15"`,
        `  size       = "db-s-1vcpu-1gb"`,
        `  region     = "nyc3"`,
        `  node_count = 1`,
        "}"
      );
      break;

    case "mysql":
      lines.push(
        `resource "digitalocean_database_cluster" "${resourceName}" {`,
        `  name       = "mysql-${suffix}-${index}"`,
        `  engine     = "mysql"`,
        `  version    = "8"`,
        `  size       = "db-s-1vcpu-1gb"`,
        `  region     = "nyc3"`,
        `  node_count = 1`,
        "}"
      );
      break;

    case "redis":
      lines.push(
        `resource "digitalocean_database_cluster" "${resourceName}" {`,
        `  name       = "redis-${suffix}-${index}"`,
        `  engine     = "redis"`,
        `  version    = "7"`,
        `  size       = "db-s-1vcpu-1gb"`,
        `  region     = "nyc3"`,
        `  node_count = 1`,
        "}"
      );
      break;

    case "mongodb":
      lines.push(
        `resource "digitalocean_database_cluster" "${resourceName}" {`,
        `  name       = "mongodb-${suffix}-${index}"`,
        `  engine     = "mongodb"`,
        `  version    = "6"`,
        `  size       = "db-s-1vcpu-1gb"`,
        `  region     = "nyc3"`,
        `  node_count = 1`,
        "}"
      );
      break;

    case "load-balancer":
      // HTTP-only for copy-paste reliability (HTTPS requires certificate)
      lines.push(
        `resource "digitalocean_loadbalancer" "${resourceName}" {`,
        `  name   = "lb-${suffix}-${index}"`,
        `  region = "nyc3"`,
        "",
        "  forwarding_rule {",
        "    entry_port      = 80",
        '    entry_protocol  = "http"',
        "    target_port     = 80",
        '    target_protocol = "http"',
        "  }",
        "",
        "  healthcheck {",
        "    port     = 80",
        '    protocol = "http"',
        '    path     = "/"',
        "  }",
      );
      // Auto-wire to all droplets
      if (dropletResourceNames.length > 0) {
        lines.push("");
        lines.push("  droplet_ids = [");
        dropletResourceNames.forEach((name) => {
          lines.push(`    digitalocean_droplet.${name}.id,`);
        });
        lines.push("  ]");
      }
      lines.push("}");
      break;

    case "spaces":
      // Globally unique bucket name with suffix
      lines.push(
        `resource "digitalocean_spaces_bucket" "${resourceName}" {`,
        `  name   = "bucket-${suffix}-${index}"`,
        `  region = "nyc3"`,
        `  acl    = "private"`,
        "}"
      );
      break;

    case "block-storage":
      lines.push(
        `resource "digitalocean_volume" "${resourceName}" {`,
        `  name                    = "volume-${suffix}-${index}"`,
        `  region                  = "nyc3"`,
        `  size                    = 100`,
        `  initial_filesystem_type = "ext4"`,
        `  description             = "Block storage volume"`,
        "}"
      );
      break;

    case "kubernetes":
      lines.push(
        `resource "digitalocean_kubernetes_cluster" "${resourceName}" {`,
        `  name    = "k8s-${suffix}-${index}"`,
        `  region  = "nyc3"`,
        `  version = "1.28.2-do.0"`,
        "",
        "  node_pool {",
        '    name       = "worker-pool"',
        '    size       = "s-2vcpu-4gb"',
        "    node_count = 3",
        "  }",
        "}"
      );
      break;

    case "container-registry":
      // Note: Only 1 registry per DO account
      lines.push(
        `# NOTE: DigitalOcean allows only ONE container registry per account.`,
        `# If you already have a registry, remove or comment out this resource.`,
        `resource "digitalocean_container_registry" "${resourceName}" {`,
        `  name                   = "registry-${suffix}"`,
        `  subscription_tier_slug = "basic"`,
        "}"
      );
      break;

    case "vpc":
      lines.push(
        `resource "digitalocean_vpc" "${resourceName}" {`,
        `  name     = "vpc-${suffix}-${index}"`,
        `  region   = "nyc3"`,
        `  ip_range = "10.10.${index}0.0/24"`,
        "}"
      );
      break;

    case "floating-ip":
      lines.push(
        `resource "digitalocean_floating_ip" "${resourceName}" {`,
        `  region = "nyc3"`,
        "}"
      );
      break;

    case "cdn":
      // Only generate if Spaces bucket exists
      if (hasSpaces && spacesResourceName) {
        lines.push(
          `resource "digitalocean_cdn" "${resourceName}" {`,
          `  origin = digitalocean_spaces_bucket.${spacesResourceName}.bucket_domain_name`,
          `  ttl    = 3600`,
          "}"
        );
      } else {
        lines.push(
          `# NOTE: CDN requires a Spaces bucket. Add a Spaces component to enable CDN.`,
          `# resource "digitalocean_cdn" "${resourceName}" {`,
          `#   origin = digitalocean_spaces_bucket.YOUR_BUCKET.bucket_domain_name`,
          `#   ttl    = 3600`,
          `# }`
        );
      }
      break;

    case "firewall":
      lines.push(
        `resource "digitalocean_firewall" "${resourceName}" {`,
        `  name = "firewall-${suffix}-${index}"`,
        "",
      );
      // Auto-wire to all droplets
      if (dropletResourceNames.length > 0) {
        lines.push("  droplet_ids = [");
        dropletResourceNames.forEach((name) => {
          lines.push(`    digitalocean_droplet.${name}.id,`);
        });
        lines.push("  ]");
        lines.push("");
      }
      lines.push(
        "  inbound_rule {",
        '    protocol         = "tcp"',
        '    port_range       = "22"',
        '    source_addresses = ["0.0.0.0/0"]',
        "  }",
        "",
        "  inbound_rule {",
        '    protocol         = "tcp"',
        '    port_range       = "80"',
        '    source_addresses = ["0.0.0.0/0"]',
        "  }",
        "",
        "  inbound_rule {",
        '    protocol         = "tcp"',
        '    port_range       = "443"',
        '    source_addresses = ["0.0.0.0/0"]',
        "  }",
        "",
        "  outbound_rule {",
        '    protocol              = "tcp"',
        '    port_range            = "1-65535"',
        '    destination_addresses = ["0.0.0.0/0"]',
        "  }",
        "}"
      );
      break;

    case "app-platform":
      // Skip - requires git repo
      lines.push(
        `# NOTE: App Platform requires a connected Git repository.`,
        `# This component cannot be auto-deployed without configuration.`,
        `# See: https://docs.digitalocean.com/products/app-platform/`,
        `#`,
        `# To deploy manually:`,
        `# 1. Go to https://cloud.digitalocean.com/apps`,
        `# 2. Click "Create App" and connect your repository`
      );
      break;

    case "functions":
      // Skip - requires git repo
      lines.push(
        `# NOTE: Functions requires a connected Git repository with function code.`,
        `# This component cannot be auto-deployed without configuration.`,
        `# See: https://docs.digitalocean.com/products/functions/`,
        `#`,
        `# To deploy manually:`,
        `# 1. Install doctl: https://docs.digitalocean.com/reference/doctl/`,
        `# 2. Run: doctl serverless deploy your-functions-directory`
      );
      break;

    case "monitoring":
      lines.push(
        `resource "digitalocean_monitor_alert" "${resourceName}" {`,
        "  alerts {",
        '    email = ["your-email@example.com"]',
        "  }",
        `  window      = "5m"`,
        `  type        = "v1/insights/droplet/cpu"`,
        `  compare     = "GreaterThan"`,
        `  value       = 80`,
        `  enabled     = true`,
        `  description = "High CPU usage alert"`,
      );
      // Auto-wire to all droplets
      if (dropletResourceNames.length > 0) {
        lines.push("");
        lines.push("  entities = [");
        dropletResourceNames.forEach((name) => {
          lines.push(`    digitalocean_droplet.${name}.id,`);
        });
        lines.push("  ]");
      }
      lines.push("}");
      break;

    default:
      lines.push(`# Unknown component type: ${component.type}`);
  }

  return lines;
}

function generateOutputs(resources: {
  droplets: string[];
  databases: string[];
  loadBalancers: string[];
  spaces: string[];
}): string[] {
  const lines: string[] = [];
  
  // Only add outputs section if we have resources to output
  const hasOutputs = 
    resources.droplets.length > 0 || 
    resources.databases.length > 0 || 
    resources.loadBalancers.length > 0 ||
    resources.spaces.length > 0;

  if (!hasOutputs) {
    return lines;
  }

  lines.push("# ============================================");
  lines.push("# OUTPUTS - View after 'terraform apply'");
  lines.push("# ============================================");
  lines.push("");

  // Droplet IPs
  if (resources.droplets.length > 0) {
    lines.push('output "droplet_ips" {');
    lines.push('  description = "Public IP addresses of all droplets"');
    lines.push("  value = {");
    resources.droplets.forEach((name) => {
      lines.push(`    ${name} = digitalocean_droplet.${name}.ipv4_address`);
    });
    lines.push("  }");
    lines.push("}");
    lines.push("");
  }

  // Load Balancer IP
  if (resources.loadBalancers.length > 0) {
    lines.push('output "load_balancer_ip" {');
    lines.push('  description = "Load balancer IP address"');
    lines.push(`  value       = digitalocean_loadbalancer.${resources.loadBalancers[0]}.ip`);
    lines.push("}");
    lines.push("");
  }

  // Database connection info
  if (resources.databases.length > 0) {
    lines.push('output "database_connection_info" {');
    lines.push('  description = "Database connection details"');
    lines.push("  sensitive   = true");
    lines.push("  value = {");
    resources.databases.forEach((name) => {
      lines.push(`    ${name} = {`);
      lines.push(`      host     = digitalocean_database_cluster.${name}.host`);
      lines.push(`      port     = digitalocean_database_cluster.${name}.port`);
      lines.push(`      user     = digitalocean_database_cluster.${name}.user`);
      lines.push(`      password = digitalocean_database_cluster.${name}.password`);
      lines.push(`      database = digitalocean_database_cluster.${name}.database`);
      lines.push(`      uri      = digitalocean_database_cluster.${name}.uri`);
      lines.push("    }");
    });
    lines.push("  }");
    lines.push("}");
    lines.push("");
  }

  // Spaces bucket info
  if (resources.spaces.length > 0) {
    lines.push('output "spaces_buckets" {');
    lines.push('  description = "Spaces bucket endpoints"');
    lines.push("  value = {");
    resources.spaces.forEach((name) => {
      lines.push(`    ${name} = {`);
      lines.push(`      name   = digitalocean_spaces_bucket.${name}.name`);
      lines.push(`      urn    = digitalocean_spaces_bucket.${name}.urn`);
      lines.push(`      domain = digitalocean_spaces_bucket.${name}.bucket_domain_name`);
      lines.push("    }");
    });
    lines.push("  }");
    lines.push("}");
  }

  return lines;
}

export function calculateMonthlyCost(placedComponents: PlacedComponent[]): number {
  return placedComponents.reduce((sum, p) => sum + p.component.monthlyCost, 0);
}
